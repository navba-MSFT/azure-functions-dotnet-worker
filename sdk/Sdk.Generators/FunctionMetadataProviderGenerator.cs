using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;


namespace Microsoft.Azure.Functions.Worker.Sdk.Generators
{
    [Generator]
    public class FunctionMetadataProviderGenerator : ISourceGenerator
    {
        public void Execute(GeneratorExecutionContext context)
        {
            // retreive the populated receiver 
            if (!(context.SyntaxReceiver is SyntaxReceiver receiver))
                return;

            Compilation compilation = context.Compilation;

            SourceText sourceText;
            using (var stringWriter = new StringWriter())
            using (var indentedTextWriter = new IndentedTextWriter(stringWriter))
            {
                indentedTextWriter.WriteLine("// <auto-generated/>");
                indentedTextWriter.WriteLine("using System;");
                indentedTextWriter.WriteLine("using System.Collections.Generic;");
                indentedTextWriter.WriteLine("using System.Collections.Immutable;");
                indentedTextWriter.WriteLine("using System.Threading.Tasks;");
                indentedTextWriter.WriteLine("using Microsoft.Azure.Functions.Worker.Grpc.Messages;");
                indentedTextWriter.WriteLine("namespace Microsoft.Azure.Functions.Worker");
                indentedTextWriter.WriteLine("{");
                indentedTextWriter.Indent++;
                indentedTextWriter.WriteLine("internal class DefaultFunctionMetadataProvider : IFunctionMetadataProvider");
                indentedTextWriter.WriteLine("{");
                indentedTextWriter.Indent++;
                WriteGetFunctionsMetadataAsyncMethod(indentedTextWriter, receiver, compilation);
                indentedTextWriter.Indent--;
                indentedTextWriter.WriteLine("}");
                indentedTextWriter.Indent--;
                indentedTextWriter.WriteLine("}");

                indentedTextWriter.Flush();
                sourceText = SourceText.From(stringWriter.ToString(), encoding: Encoding.UTF8);
            }

            // Add the source code to the compilation
            context.AddSource($"SourceGeneratedFunctionMetadataProvider.cs", sourceText);
        }

        private static void WriteGetFunctionsMetadataAsyncMethod(IndentedTextWriter indentedTextWriter, SyntaxReceiver receiver, Compilation compilation)
        {
            indentedTextWriter.WriteLine("public virtual async Task<ImmutableArray<RpcFunctionMetadata>> GetFunctionMetadataAsync(string directory)");
            indentedTextWriter.WriteLine("{");
            indentedTextWriter.Indent++;
            indentedTextWriter.WriteLine("var metadataList = new List<RpcFunctionMetadata>();");
            AddFunctionMetadataInfo(indentedTextWriter, receiver, compilation);
            indentedTextWriter.WriteLine("return Task.FromResult(metadataList.ToImmutableArray());");
            indentedTextWriter.Indent--;
            indentedTextWriter.WriteLine("}");
        }

        private static void AddFunctionMetadataInfo(IndentedTextWriter indentedTextWriter, SyntaxReceiver receiver, Compilation compilation)
        {
            var assemblyName = compilation.Assembly.Name;
            var scriptFile = Path.Combine("bin/" + assemblyName + ".dll");

            foreach (MethodDeclarationSyntax method in receiver.CandidateMethods)
            {

                var functionClass = (ClassDeclarationSyntax)method.Parent!;
                var functionName = functionClass.Identifier.ValueText;
                var entryPoint = assemblyName + "." + functionName + "." + method.Identifier.ValueText;

                indentedTextWriter.WriteLine("var" + functionName + "= new RpcFunctionMetadata();");
                indentedTextWriter.WriteLine("functionMetadata.Name = \"" + functionName + "\";");
                indentedTextWriter.WriteLine("functionMetadata.ScriptFile = \"" + scriptFile + "\";");
                indentedTextWriter.WriteLine("functionMetadata.Language = \"dotnet-isolated\";");
                indentedTextWriter.WriteLine("functionMetadata.EntryPoint = \"" + entryPoint + "\";");
                indentedTextWriter.WriteLine("functionMetadata.IsProxy = false;");
                indentedTextWriter.WriteLine("functionMetadata.FunctionId = Guid.NewGuid().ToString();");
                AddBindingInfo(indentedTextWriter, method, compilation, functionName);
                indentedTextWriter.WriteLine("functionMetadataResults.Add(" + functionName + ");");
            }

        }

        private static void AddBindingInfo(IndentedTextWriter indentedTextWriter, MethodDeclarationSyntax method, Compilation compilation, string functionName)
        {
            var model = compilation.GetSemanticModel(method.SyntaxTree);

            foreach (ParameterSyntax parameter in method.ParameterList.Parameters)
            {
                if (parameter.AttributeLists.Count == 0)
                {
                    continue;
                }

                IParameterSymbol parameterSymbol = model.GetDeclaredSymbol(parameter) as IParameterSymbol;
                AttributeData attributeData = parameterSymbol.GetAttributes().First();

                AttributeSyntax attributeSyntax = parameter.AttributeLists.First().Attributes.First();
                IMethodSymbol attribMethodSymbol = model.GetSymbolInfo(attributeSyntax).Symbol as IMethodSymbol;

                if (attribMethodSymbol?.Parameters is null)
                {
                    throw new InvalidOperationException($"The constructor of attribute with syntax '{nameof(attributeSyntax)}' is invalid");
                }

                IDictionary<string, object> attributeProperties = GetAttributeProperties(attribMethodSymbol, attributeData);

                string attributeName = attributeData.AttributeClass.Name;

                // create binding metadata w/ info below and add to function metadata created above
                var bindingName = parameter.Identifier.ValueText; // correct?
                var bindingType = attributeName.Replace("Attribute", "");

                var bindingDirection = "In";

                if (parameterSymbol.Type is INamedTypeSymbol parameterNamedType &&
                    parameterNamedType.IsGenericType &&
                    parameterNamedType.ConstructUnboundGenericType().ToString() == "Microsoft.Azure.Functions.DotNetWorker.OutputBinding<>")
                {
                    bindingDirection = "Out";
                }

                // create raw binding
                indentedTextWriter.WriteLine("var " + bindingName + " = @\"{" +
                    "\"\"name\"\": \"\"" + bindingName + "\"\"," +
                    "\"\"type\"\": \"\"" + bindingType + "\"\"," +
                    "\"\"direction\"\": \"\"" + bindingDirection + "\"\"," +
                    "\"\"authLevel\"\": \"\"Anonymous\"\"," +
                    "\"\"methods\"\": [ \"\"get\"\",\"\"post\"\"]}");
/*
                foreach (var prop in attributeProperties)
                {
                    var propertyName = prop.Key;
                    var propertyValue = FormatObject(prop.Value);

                    if (prop.Value.GetType().IsArray)
                    {
                        string jarr = FormatArray(prop.Value as IEnumerable);
                        sourceBuilder.AppendLine(jarr);
                        sourceBuilder.Append(@"raw[""" + propertyName + @$"""] = jarr{arrayCount++};");
                    }
                    else
                    {
                        sourceBuilder.Append(@"
                           raw[""" + propertyName + @"""] =" + propertyValue + ";");
                    }
                }*/

                // add to raw bindings
                indentedTextWriter.WriteLine(functionName + ".RawBindings.Add(" + bindingName + ");");

                // create a binding info
                var bindingInfo = "";

                // add to binding info
                indentedTextWriter.WriteLine(functionName + ".RawBindings.Add(" + bindingName + "," + bindingInfo + ");");

            }
        }

        public void Initialize(GeneratorInitializationContext context)
        {
#if DEBUG
            if (!Debugger.IsAttached)
            {
                Debugger.Launch();
            }
#endif 
            Debug.WriteLine("Initalize code generator");
            // Register a syntax receiver that will be created for each generation pass
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
        }

        /// <summary>
        /// Created on demand before each generation pass
        /// </summary>
        private class SyntaxReceiver : ISyntaxReceiver
        {
            public List<MethodDeclarationSyntax> CandidateMethods { get; } = new List<MethodDeclarationSyntax>();

            /// <summary>
            /// Called for every syntax node in the compilation, we can inspect the nodes and save any information useful for generation
            /// </summary>
            public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
            {
                if (syntaxNode is MethodDeclarationSyntax methodSyntax)
                {
                    foreach (var p in methodSyntax.ParameterList.Parameters)
                    {
                        if (p.AttributeLists.Count > 0)
                        {
                            CandidateMethods.Add(methodSyntax);
                            break;
                        }
                    }
                }
            }
        }

        internal static IDictionary<string, object> GetAttributeProperties(IMethodSymbol attribMethodSymbol, AttributeData attributeData)
        {
            Dictionary<string, object> argumentData = new();
            if (attributeData.ConstructorArguments.Any())
            {
                LoadConstructorArguments(attribMethodSymbol, attributeData, argumentData);
            }

            foreach (var namedArgument in attributeData.NamedArguments)
            {
                if (namedArgument.Value.Value != null)
                {
                    argumentData[namedArgument.Key] = namedArgument.Value.Value;
                }
            }

            return argumentData;
        }
        internal static void LoadConstructorArguments(IMethodSymbol attribMethodSymbol, AttributeData attributeData, IDictionary<string, object> dict)
        {
            if (attribMethodSymbol.Parameters.Length < attributeData.ConstructorArguments.Length)
            {
                throw new InvalidOperationException($"The constructor at '{nameof(attribMethodSymbol)}' has less total arguments than '{nameof(attributeData)}'.");
            }

            // It's fair to assume than constructor arguments appear before named arguments, and
            // that the constructor names would match the property names
            for (int i = 0; i < attributeData.ConstructorArguments.Length; i++)
            {
                var argumentName = attribMethodSymbol.Parameters[i].Name;

                var arg = attributeData.ConstructorArguments[i];
                switch (arg.Kind)
                {
                    case TypedConstantKind.Error:
                        break;
                    case TypedConstantKind.Primitive:
                    case TypedConstantKind.Enum:
                        dict[argumentName] = arg.Value;
                        break;
                    case TypedConstantKind.Type:
                        break;
                    case TypedConstantKind.Array:
                        var arrayValues = arg.Values.Select(a => a.Value.ToString()).ToArray();
                        dict[argumentName] = arrayValues;
                        break;
                    default:
                        break;
                }
            }
        }
    }
}
